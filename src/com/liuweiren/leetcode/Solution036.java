package com.liuweiren.leetcode;
/**
 *
 * 360 - 369
 *
 * <br><br>created by <b>LWR</b> on <b>2020/3/21</b>
 * @author LWR
 */
public class Solution036 {
    /**
     * <a href="https://leetcode-cn.com/problems/water-and-jug-problem/">365.<a/>
     *
     * Water and Jug Problem(水壶问题)<br>
     *
     * 有两个容量分别为x升和y升的水壶以及无限多的水。请判断能否通过使用这两个水壶，从而可以得到恰好z升的水？
     * 如果可以，最后请用以上水壶中的一或两个来盛放取得的z升水。
     * 你允许：
     *      装满任意一个水壶
     *      清空任意一个水壶
     *      从一个水壶向另外一个水壶倒水，直到装满或者倒空
     *
     * 例子：
     *      输入: x = 3, y = 5, z = 4
     *      输出: True
     *
     * @param x
     * @param y
     * @param z
     * @return
     */
    public boolean canMeasureWater(int x, int y, int z) {
        /*
         * 解法说明来源于官方
         */
        if(z == 0 || x == z || y == z || x + y == z) {
            return true;
        }

        if (x + y < z) {
            return false;
        }

        return z % gcd(x, y) == 0;

        /*
        预备知识：贝祖定理

        我们认为，每次操作只会让桶里的水总量增加 x，增加 y，减少 x，或者减少 y。
        你可能认为这有问题：如果往一个不满的桶里放水，或者把它排空呢？那变化量不就不是 x 或者 y 了吗？接下来我们来解释这一点：
             首先要清楚，在题目所给的操作下，两个桶不可能同时有水且不满。因为观察所有题目中的操作，操作的结果都至少有一个桶是空的或者满的；
             其次，对一个不满的桶加水是没有意义的。因为如果另一个桶是空的，那么这个操作的结果等价于直接从初始状态给这个桶加满水；
             而如果另一个桶是满的，那么这个操作的结果等价于从初始状态分别给两个桶加满；
             再次，把一个不满的桶里面的水倒掉是没有意义的。因为如果另一个桶是空的，那么这个操作的结果等价于回到初始状态；
             而如果另一个桶是满的，那么这个操作的结果等价于从初始状态直接给另一个桶倒满。
        因此，我们可以认为每次操作只会给水的总量带来 x 或者 y 的变化量。因此我们的目标可以改写成：找到一对整数 a, b, 使得
             ax + by = z
        而只要满足 z <= x + y，且这样的a,b存在，那么我们的目标就是可以达成的。这是因为：
             若 a >= 0, b >= 0, 那么显然可以达成目标。
             若 a < 0，那么可以进行以下操作：
                 往 y 壶倒水；
                 把 y 壶的水倒入 x 壶；
                 如果 y 壶不为空，那么 x 壶肯定是满的，把 x 壶倒空，然后再把 y 壶的水倒入 x 壶。
                 重复以上操作直至某一步时 x 壶进行了 a 次倒空操作，y 壶进行了 b 次倒水操作。
             若 b < 0，方法同上，x 与 y 互换。

        而贝祖定理告诉我们，ax + by = z 有解当且仅当 z 是 x, y 的最大公约数的倍数。
        因此我们只需要找到 x,y 的最大公约数并判断 z 是否是它的倍数即可。

        复杂度分析
             时间复杂度：O(log(min(x, y)))，取决于计算最大公约数所使用的辗转相除法。
             空间复杂度：O(1)，只需要常数个变量。
        */
    }

    private int gcd(int x, int y) {
        while (y != 0) {
            int m = x % y;
            x = y;
            y = m;
        }

        return x;
    }
}
